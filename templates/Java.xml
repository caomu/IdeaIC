<templateSet group="Java">
  <template name="recur" value="private void recursion(int level, int param) {&#10;  // recursion terminator&#10;  if (level &gt; MAX_LEVEL) {&#10;  &#10;    return;&#10;  }&#10;&#10;  // process current layer&#10;  process(level, param);&#10;&#10;  // dig into lower layer&#10;  recursion(level: level + 1, newParam);&#10;&#10;  // clean current layer&#10;&#10;}" description="recursion" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="uf" value="private static class UnionFind {&#10;    private int[] roots;&#10;&#10;    protected UnionFind(int n) {&#10;        this.roots = IntStream.range(0, n).toArray();&#10;    }&#10;    &#10;    protected int[] getRoots() {&#10;        return this.roots;&#10;    }&#10;    &#10;    protected void union(int p, int q) {&#10;        roots[this.findRoot(p)] = this.findRoot(q);&#10;    }&#10;&#10;    protected void union(int... p) {&#10;        for (int i = 1; i &lt; p.length; i++) {&#10;            this.union(p[i], p[0]);&#10;        }&#10;    }&#10;&#10;    protected int findRoot(int i) {&#10;        int root = i;&#10;        while (root != roots[root]) {&#10;            root = roots[root];&#10;        }&#10;        int t;&#10;        while (i != roots[root]) {&#10;            t = roots[i];&#10;            roots[i] = root;&#10;            i = t;&#10;        }&#10;        return root;&#10;    }&#10;&#10;    protected boolean isConnected(int p, int q) {&#10;        return this.findRoot(p) == this.findRoot(q);&#10;    }&#10;    &#10;    protected int getCount() {&#10;        Set&lt;Integer&gt; rootSet = new HashSet&lt;&gt;();&#10;        Arrays.stream(this.roots).forEach(root -&gt; rootSet.add(this.findRoot(root)));&#10;        return rootSet.size();&#10;    }&#10;}" description="union find" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="souta" value="System.out.println(Arrays.toString($ARRAY$));" description="System.out.println(Arrays.toString($ARRAY$));" toReformat="true" toShortenFQNames="true">
    <variable name="ARRAY" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bfs" value="&#10;public int bfs(TreeNode root) {&#10;    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); // 核心数据结构&#10;    Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); // 避免走回头路&#10;&#10;    q.offer(root); // 将起点加入队列&#10;    visited.add(root);&#10;    int step = 1; // 记录扩散的步数&#10;&#10;    while (!q.isEmpty()) {&#10;        /* 将当前队列中的所有节点向四周扩散 */&#10;        int width = q.size();&#10;        for (int i = 0; i &lt; width; i++) {&#10;            TreeNode cur = q.poll();&#10;            /* 划重点：这里判断是否到达终点 */&#10;            if (cur.left == null &amp;&amp; cur.right == null) {&#10;                return step;&#10;            }&#10;            /* 将 cur 的相邻节点加入队列 */&#10;            if (cur.left != null &amp;&amp; !visited.contains(cur.left)) {&#10;                q.offer(cur.left);&#10;                visited.add(cur.left);&#10;            }&#10;            if (cur.right != null &amp;&amp; !visited.contains(cur.right)) {&#10;                q.offer(cur.right);&#10;                visited.add(cur.right);&#10;            }&#10;        }&#10;        /* 划重点：更新步数在这里 */&#10;        step++;&#10;    }&#10;    return step;&#10;}" description="Breadth-first search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="dfs" value="private void dfs(TreeNode node, int level, List&lt;Integer&gt; res, Set&lt;Integer&gt; visited) {&#10;    // check if can end&#10;    if (node == null) {&#10;        return;&#10;    }&#10;    visited.add(node);&#10;    // process current depth level&#10;    if (res.size() == level) {&#10;        res.add(node.val);&#10;    }&#10;    // dig into next depth&#10;    level++;&#10;    if(!visited.contains(node.right)){&#10;        this.dfs(node.right, level, res);&#10;    }&#10;    if(!visited.contains(node.left)) {&#10;        this.dfs(node.left, level, res);&#10;    }&#10;}" description="Depth-First-Search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bs" value="&#10;while(left &lt;= right){&#10;  mid = (left + right) &gt;&gt; 1;&#10;  if(arr[mid] &gt; key) {&#10;    //比关键字大则关键字在左区域&#10;    right = mid - 1;&#10;  } else if(arr[mid] &lt; key) {&#10;    //比关键字小则关键字在右区域&#10;    left = mid + 1;&#10;  } else {&#10;    return mid;&#10;  }" description="Binary Search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt-iot" value="    /**&#10;     * 递归中序遍历&#10;     * */&#10;    private void inOrderTraversal(TreeNode node, StringBuilder sb){&#10;        if(node==null){ //如果结点为空则返回&#10;            return;&#10;        }&#10;        inOrderTraversal(node.left, sb);//访问左孩子&#10;        sb.append(node.val);//访问根节点&#10;        inOrderTraversal(node.right, sb);//访问右孩子&#10;    }" description="binary tree in-order traversal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt-pot" value="    /**&#10;     * 递归前序遍历&#10;     * */&#10;    private void preOrderTraversal(TreeNode node, StringBuilder sb){&#10;        if(node==null) {//如果结点为空则返回&#10;            return;&#10;        }&#10;        sb.append(node.val);//访问根节点&#10;        preOrderTraversal(node.left, sb);//访问左孩子&#10;        preOrderTraversal(node.right, sb);//访问右孩子&#10;    }" description="binary tree pre-order traversal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt-poot" value="    /**&#10;     * 递归后序遍历&#10;     * */&#10;    private void postOrderTraversal(TreeNode node, StringBuilder sb){&#10;        if(node==null) {//如果结点为空则返回&#10;            return;&#10;        }&#10;        postOrderTraversal(node.left, sb);//访问左孩子&#10;        postOrderTraversal(node.right, sb);//访问右孩子&#10;        sb.append(node.val);//访问根节点&#10;    }" description="binary tree post-order traversal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="trie" value="class Trie {&#10;    Trie[] children;&#10;    boolean isWord;&#10;&#10;    /**&#10;     * Initialize your data structure here.&#10;     */&#10;    public Trie() {&#10;        this.children = new Trie[26];&#10;        this.isWord = false;&#10;    }&#10;&#10;    /**&#10;     * Inserts a word into the trie.&#10;     */&#10;    public void insert(String word) {&#10;        Trie curr = this;&#10;        for (int i = 0; i &lt; word.length(); i++) {&#10;            char c = word.charAt(i);&#10;            if (curr.children[c - 'a'] == null) {&#10;                curr.children[c - 'a'] = new Trie();&#10;            }&#10;            curr = curr.children[c - 'a'];&#10;        }&#10;        curr.isWord = true;&#10;    }&#10;&#10;    /**&#10;     * Returns if the word is in the trie.&#10;     */&#10;    public boolean search(String word) {&#10;        Trie leaf = this.findLeafTrie(word);&#10;        return leaf != null &amp;&amp; leaf.isWord;&#10;    }&#10;&#10;    /**&#10;     * Returns if there is any word in the trie that starts with the given prefix.&#10;     */&#10;    public boolean startsWith(String prefix) {&#10;        return this.findLeafTrie(prefix) != null;&#10;    }&#10;&#10;    private Trie findLeafTrie(String word) {&#10;        Trie curr = this;&#10;        for (int i = 0; i &lt; word.length(); i++) {&#10;            curr = curr.children[word.charAt(i) - 'a'];&#10;            if (curr == null) {&#10;                return null;&#10;            }&#10;        }&#10;        return curr;&#10;    }&#10;}" description="Trie search" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="res" value="        int res = 0;&#10;&#10;        return res;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="tire" value="private class Trie {&#10;    Trie[] children;&#10;    boolean isWord;&#10;&#10;    /**&#10;     * Initialize your data structure here.&#10;     */&#10;    public Trie() {&#10;        this.children = new Trie[26];&#10;        this.isWord = false;&#10;    }&#10;&#10;    /**&#10;     * Inserts a word into the trie.&#10;     */&#10;    public void insert(String word) {&#10;        this.insert(word.toCharArray());&#10;    }&#10;&#10;    public void insert(char[] chars) {&#10;        Trie curr = this;&#10;        for (int i = 0; i &lt; chars.length; i++) {&#10;            char c = chars[i];&#10;            if (curr.children[c - 'a'] == null) {&#10;                curr.children[c - 'a'] = new Trie();&#10;            }&#10;            curr = curr.children[c - 'a'];&#10;        }&#10;        curr.isWord = true;&#10;    }&#10;&#10;    /**&#10;     * Returns if the word is in the trie.&#10;     */&#10;    public boolean search(String word) {&#10;        Trie leaf = this.findLeafTrie(word);&#10;        return leaf != null &amp;&amp; leaf.isWord;&#10;    }&#10;&#10;    /**&#10;     * Returns if there is any word in the trie that starts with the given prefix.&#10;     */&#10;    public boolean startsWith(String prefix) {&#10;        return this.findLeafTrie(prefix) != null;&#10;    }&#10;&#10;    private Trie findLeafTrie(String word) {&#10;        Trie curr = this;&#10;        for (int i = 0; i &lt; word.length(); i++) {&#10;            curr = curr.children[word.charAt(i) - 'a'];&#10;            if (curr == null) {&#10;                return null;&#10;            }&#10;        }&#10;        return curr;&#10;    }&#10;}" shortcut="SPACE" description="tire" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="wuf" value="private static class WeightUnionFind {&#10;&#10;    private int[] parent;&#10;&#10;    /**&#10;     * 指向的父结点的权值&#10;     */&#10;    private double[] weight;&#10;&#10;&#10;    public WeightUnionFind(int n) {&#10;        this.parent = IntStream.range(0, n).toArray();&#10;        this.weight = new double[n];&#10;        IntStream.range(0, n).forEach(i -&gt; this.weight[i] = 1.0d);&#10;    }&#10;&#10;    public void union(int x, int y, double value) {&#10;        int rootX = this.find(x);&#10;        int rootY = this.find(y);&#10;        if (rootX == rootY) {&#10;            return;&#10;        }&#10;&#10;        this.parent[rootX] = rootY;&#10;        // 关系式的推导请见「参考代码」下方的示意图&#10;        this.weight[rootX] = this.weight[y] * value / this.weight[x];&#10;    }&#10;&#10;    /**&#10;     * 路径压缩&#10;     *&#10;     * @param x&#10;     * @return 根结点的 id&#10;     */&#10;    public int find(int x) {&#10;        if (x != this.parent[x]) {&#10;            int origin = this.parent[x];&#10;            this.parent[x] = this.find(this.parent[x]);&#10;            this.weight[x] *= this.weight[origin];&#10;        }&#10;        return this.parent[x];&#10;    }&#10;&#10;    public double isConnected(int x, int y) {&#10;        int rootX = this.find(x);&#10;        int rootY = this.find(y);&#10;        if (rootX == rootY) {&#10;            return this.weight[x] / this.weight[y];&#10;        } else {&#10;            return -1.0d;&#10;        }&#10;    }&#10;}" description="WeightUnionFind" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt" value="    private void backtrack(int[] nums, int depth, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) {&#10;        if (depth == nums.length) {&#10;            res.add(new ArrayList&lt;&gt;(path));&#10;            return;&#10;        }&#10;&#10;        for (int i = 0; i &lt; nums.length; i++) {&#10;            if (!used[i]) {&#10;                path.addLast(nums[i]);&#10;                used[i] = true;&#10;&#10;                //System.out.println(&quot;递归之前 =&gt; &quot; + path);&#10;                backtrack(nums, depth + 1, path, used, res);&#10;&#10;                used[i] = false;&#10;                path.removeLast();&#10;                //System.out.println(&quot;递归之后 =&gt; &quot; + path);&#10;            }&#10;        }&#10;    }&#10;" description="backtrack" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="btwithsort" value="    private void backtrack(int[] nums, int depth, Deque&lt;Integer&gt; path, int begin, List&lt;List&lt;Integer&gt;&gt; res) {&#10;        if (depth == nums.length) {&#10;            res.add(new ArrayList&lt;&gt;(path));&#10;            return;&#10;        }&#10;&#10;        for (int i = begin; i &lt; nums.length; i++) {&#10;            path.addLast(nums[i]);&#10;            //System.out.println(&quot;递归之前 =&gt; &quot; + path);&#10;            backtrack(nums, depth + 1, path, begin + 1, res);&#10;            path.removeLast();&#10;            //System.out.println(&quot;递归之后 =&gt; &quot; + path);&#10;        }&#10;    }&#10;" description="backtrack with sort" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
</templateSet>