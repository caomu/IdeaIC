<templateSet group="Java">
  <template name="recur" value="private void recursion(int level, int param) {&#10;  // recursion terminator&#10;  if (level &gt; MAX_LEVEL) {&#10;  &#10;    return;&#10;  }&#10;&#10;  // process current layer&#10;  process(level, param);&#10;&#10;  // dig into lower layer&#10;  recursion(level: level + 1, newParam);&#10;&#10;  // clean current layer&#10;&#10;}" description="recursion" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="uf" value="private class UnionFind {&#10;    private final int[] roots;&#10;&#10;    protected UnionFind(int n) {&#10;        this.roots = IntStream.range(0, n).toArray();&#10;    }&#10;    &#10;    protected int[] getRoots() {&#10;        return this.roots;&#10;    }&#10;    &#10;    protected void union(int p, int q) {&#10;        roots[this.findRoot(p)] = this.findRoot(q);&#10;    }&#10;&#10;    protected void union(int... p) {&#10;        for (int i = 1; i &lt; p.length; i++) {&#10;            this.union(p[i], p[0]);&#10;        }&#10;    }&#10;&#10;    protected int findRoot(int i) {&#10;        int root = i;&#10;        while (root != roots[root]) {&#10;            root = roots[root];&#10;        }&#10;        int t;&#10;        while (i != roots[root]) {&#10;            t = roots[i];&#10;            roots[i] = root;&#10;            i = t;&#10;        }&#10;        return root;&#10;    }&#10;&#10;    protected boolean isConnected(int p, int q) {&#10;        return this.findRoot(p) == this.findRoot(q);&#10;    }&#10;    &#10;    protected int getCount() {&#10;        Set&lt;Integer&gt; rootSet = new HashSet&lt;&gt;();&#10;        Arrays.stream(this.roots).forEach(root -&gt; rootSet.add(this.findRoot(root)));&#10;        return rootSet.size();&#10;    }&#10;}" description="union find" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="souta" value="System.out.println(Arrays.toString($ARRAY$));" description="System.out.println(Arrays.toString($ARRAY$));" toReformat="true" toShortenFQNames="true">
    <variable name="ARRAY" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bfs" value="    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();&#10;    Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;();&#10;&#10;    q.offer(root);&#10;    visited.add(root);&#10;    int step = 1;&#10;&#10;    while (!q.isEmpty()) {&#10;        int width = q.size();&#10;        for (int i = 0; i &lt; width; i++) {&#10;            TreeNode cur = q.poll();&#10;            if (cur.left == null &amp;&amp; cur.right == null) {&#10;                return step;&#10;            }&#10;            if (cur.left != null &amp;&amp; !visited.contains(cur.left)) {&#10;                q.offer(cur.left);&#10;                visited.add(cur.left);&#10;            }&#10;            if (cur.right != null &amp;&amp; !visited.contains(cur.right)) {&#10;                q.offer(cur.right);&#10;                visited.add(cur.right);&#10;            }&#10;        }&#10;        step++;&#10;    }" description="Breadth-first search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="dfs" value="private void dfs(TreeNode node, int level, List&lt;Integer&gt; res, Set&lt;Integer&gt; visited) {&#10;    // check if can end&#10;    if (node == null) {&#10;        return;&#10;    }&#10;    visited.add(node);&#10;    // process current depth level&#10;    if (res.size() == level) {&#10;        res.add(node.val);&#10;    }&#10;    // dig into next depth&#10;    level++;&#10;    if(!visited.contains(node.right)){&#10;        this.dfs(node.right, level, res);&#10;    }&#10;    if(!visited.contains(node.left)) {&#10;        this.dfs(node.left, level, res);&#10;    }&#10;}" description="Depth-First-Search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bs" value="&#10;while(left &lt;= right){&#10;  mid = (left + right) &gt;&gt; 1;&#10;  if(arr[mid] &gt; key) {&#10;    //比关键字大则关键字在左区域&#10;    right = mid - 1;&#10;  } else if(arr[mid] &lt; key) {&#10;    //比关键字小则关键字在右区域&#10;    left = mid + 1;&#10;  } else {&#10;    return mid;&#10;  }" description="Binary Search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt-iot" value="    /**&#10;     * 递归中序遍历&#10;     * */&#10;    private void inOrderTraversal(TreeNode node, StringBuilder sb){&#10;        if(node==null){ //如果结点为空则返回&#10;            return;&#10;        }&#10;        inOrderTraversal(node.left, sb);//访问左孩子&#10;        sb.append(node.val);//访问根节点&#10;        inOrderTraversal(node.right, sb);//访问右孩子&#10;    }" description="binary tree in-order traversal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt-pot" value="    /**&#10;     * 递归前序遍历&#10;     * */&#10;    private void preOrderTraversal(TreeNode node, StringBuilder sb){&#10;        if(node==null) {//如果结点为空则返回&#10;            return;&#10;        }&#10;        sb.append(node.val);//访问根节点&#10;        preOrderTraversal(node.left, sb);//访问左孩子&#10;        preOrderTraversal(node.right, sb);//访问右孩子&#10;    }" description="binary tree pre-order traversal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt-poot" value="    /**&#10;     * 递归后序遍历&#10;     * */&#10;    private void postOrderTraversal(TreeNode node, StringBuilder sb){&#10;        if(node==null) {//如果结点为空则返回&#10;            return;&#10;        }&#10;        postOrderTraversal(node.left, sb);//访问左孩子&#10;        postOrderTraversal(node.right, sb);//访问右孩子&#10;        sb.append(node.val);//访问根节点&#10;    }" description="binary tree post-order traversal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="trie" value="private class Trie {&#10;    protected Trie[] children;&#10;    protected boolean isWord;&#10;&#10;    protected Trie() {&#10;        this.children = new Trie[26];&#10;        this.isWord = false;&#10;    }&#10;&#10;    protected void insert(String word) {&#10;        Trie curr = this;&#10;        for (int i = 0; i &lt; word.length(); i++) {&#10;            char c = word.charAt(i);&#10;            if (curr.children[c - 'a'] == null) {&#10;                curr.children[c - 'a'] = new Trie();&#10;            }&#10;            curr = curr.children[c - 'a'];&#10;        }&#10;        curr.isWord = true;&#10;    }&#10;&#10;    protected boolean search(String word) {&#10;        Trie leaf = this.findLeafTrie(word);&#10;        return leaf != null &amp;&amp; leaf.isWord;&#10;    }&#10;&#10;    protected boolean startsWith(String prefix) {&#10;        return this.findLeafTrie(prefix) != null;&#10;    }&#10;&#10;    protected Trie findLeafTrie(String word) {&#10;        Trie curr = this;&#10;        for (int i = 0; i &lt; word.length(); i++) {&#10;            curr = curr.children[word.charAt(i) - 'a'];&#10;            if (curr == null) {&#10;                return null;&#10;            }&#10;        }&#10;        return curr;&#10;    }&#10;}" description="Trie search" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="res" value="        int result = 0;&#10;&#10;        return result;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="wuf" value="private static class WeightUnionFind {&#10;&#10;    private int[] parent;&#10;&#10;    /**&#10;     * 指向的父结点的权值&#10;     */&#10;    private double[] weight;&#10;&#10;&#10;    public WeightUnionFind(int n) {&#10;        this.parent = IntStream.range(0, n).toArray();&#10;        this.weight = new double[n];&#10;        IntStream.range(0, n).forEach(i -&gt; this.weight[i] = 1.0d);&#10;    }&#10;&#10;    public void union(int x, int y, double value) {&#10;        int rootX = this.find(x);&#10;        int rootY = this.find(y);&#10;        if (rootX == rootY) {&#10;            return;&#10;        }&#10;&#10;        this.parent[rootX] = rootY;&#10;        // 关系式的推导请见「参考代码」下方的示意图&#10;        this.weight[rootX] = this.weight[y] * value / this.weight[x];&#10;    }&#10;&#10;    /**&#10;     * 路径压缩&#10;     *&#10;     * @param x&#10;     * @return 根结点的 id&#10;     */&#10;    public int find(int x) {&#10;        if (x != this.parent[x]) {&#10;            int origin = this.parent[x];&#10;            this.parent[x] = this.find(this.parent[x]);&#10;            this.weight[x] *= this.weight[origin];&#10;        }&#10;        return this.parent[x];&#10;    }&#10;&#10;    public double isConnected(int x, int y) {&#10;        int rootX = this.find(x);&#10;        int rootY = this.find(y);&#10;        if (rootX == rootY) {&#10;            return this.weight[x] / this.weight[y];&#10;        } else {&#10;            return -1.0d;&#10;        }&#10;    }&#10;}" description="WeightUnionFind" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt" value="    private void backtrack(int[] nums, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) {&#10;        if (path.size() == nums.length) {&#10;            //System.out.println(&quot;递归命中 =&gt; &quot; + path);&#10;            res.add(new ArrayList&lt;&gt;(path));&#10;            return;&#10;        }&#10;        for (int i = 0; i &lt; nums.length; i++) {&#10;            if (used[i]) {&#10;                continue;&#10;            }&#10;            path.addLast(nums[i]);&#10;            used[i] = true;&#10;            //System.out.println(&quot;递归之前 =&gt; &quot; + path);&#10;            backtrack(nums, path, used, res);&#10;            used[i] = false;&#10;            path.removeLast();&#10;            //System.out.println(&quot;递归之后 =&gt; &quot; + path);&#10;        }&#10;    }&#10;" description="backtrack" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="btwithsort" value="    private void backtrack(int[] nums, Deque&lt;Integer&gt; path, int begin, List&lt;List&lt;Integer&gt;&gt; res) {&#10;        if (begin == nums.length) {&#10;            res.add(new ArrayList&lt;&gt;(path));&#10;            return;&#10;        }&#10;&#10;        for (int i = begin; i &lt; nums.length; i++) {&#10;            path.addLast(nums[i]);&#10;            //System.out.println(&quot;递归之前 =&gt; &quot; + path);&#10;            backtrack(nums, path, begin + 1, res);&#10;            // 只能用一次 backtrack(nums, path, i + 1, res);&#10;            path.removeLast();&#10;            //System.out.println(&quot;递归之后 =&gt; &quot; + path);&#10;        }&#10;    }&#10;" description="backtrack with sort" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="dpq" value="// https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-in-java-using-priorityqueue/&#10;public class DPQ { &#10;    private int dist[]; &#10;    private Set&lt;Integer&gt; settled; &#10;    private PriorityQueue&lt;Node&gt; pq; &#10;    private int V; // Number of vertices &#10;    List&lt;List&lt;Node&gt; &gt; adj; &#10;  &#10;    public DPQ(int V) &#10;    { &#10;        this.V = V; &#10;        dist = new int[V]; &#10;        settled = new HashSet&lt;Integer&gt;(); &#10;        pq = new PriorityQueue&lt;Node&gt;(V, new Node()); &#10;    } &#10;  &#10;    // Function for Dijkstra's Algorithm &#10;    public void dijkstra(List&lt;List&lt;Node&gt; &gt; adj, int src) &#10;    { &#10;        this.adj = adj; &#10;  &#10;        for (int i = 0; i &lt; V; i++) &#10;            dist[i] = Integer.MAX_VALUE; &#10;  &#10;        // Add source node to the priority queue &#10;        pq.add(new Node(src, 0)); &#10;  &#10;        // Distance to the source is 0 &#10;        dist[src] = 0; &#10;        while (settled.size() != V) { &#10;  &#10;            // remove the minimum distance node  &#10;            // from the priority queue  &#10;            int u = pq.remove().node; &#10;  &#10;            // adding the node whose distance is &#10;            // finalized &#10;            settled.add(u); &#10;  &#10;            e_Neighbours(u); &#10;        } &#10;    } &#10;  &#10;    // Function to process all the neighbours  &#10;    // of the passed node &#10;    private void e_Neighbours(int u) &#10;    { &#10;        int edgeDistance = -1; &#10;        int newDistance = -1; &#10;  &#10;        // All the neighbors of v &#10;        for (int i = 0; i &lt; adj.get(u).size(); i++) { &#10;            Node v = adj.get(u).get(i); &#10;  &#10;            // If current node hasn't already been processed &#10;            if (!settled.contains(v.node)) { &#10;                edgeDistance = v.cost; &#10;                newDistance = dist[u] + edgeDistance; &#10;  &#10;                // If new distance is cheaper in cost &#10;                if (newDistance &lt; dist[v.node]) &#10;                    dist[v.node] = newDistance; &#10;  &#10;                // Add the current node to the queue &#10;                pq.add(new Node(v.node, dist[v.node])); &#10;            } &#10;        } &#10;    } &#10;  &#10;    // Driver code &#10;    public static void main(String arg[]) &#10;    { &#10;        int V = 5; &#10;        int source = 0; &#10;  &#10;        // Adjacency list representation of the  &#10;        // connected edges &#10;        List&lt;List&lt;Node&gt; &gt; adj = new ArrayList&lt;List&lt;Node&gt; &gt;(); &#10;  &#10;        // Initialize list for every node &#10;        for (int i = 0; i &lt; V; i++) { &#10;            List&lt;Node&gt; item = new ArrayList&lt;Node&gt;(); &#10;            adj.add(item); &#10;        } &#10;  &#10;        // Inputs for the DPQ graph &#10;        adj.get(0).add(new Node(1, 9)); &#10;        adj.get(0).add(new Node(2, 6)); &#10;        adj.get(0).add(new Node(3, 5)); &#10;        adj.get(0).add(new Node(4, 3)); &#10;  &#10;        adj.get(2).add(new Node(1, 2)); &#10;        adj.get(2).add(new Node(3, 4)); &#10;  &#10;        // Calculate the single source shortest path &#10;        DPQ dpq = new DPQ(V); &#10;        dpq.dijkstra(adj, source); &#10;  &#10;        // Print the shortest path to all the nodes &#10;        // from the source node &#10;        System.out.println(&quot;The shorted path from node :&quot;); &#10;        for (int i = 0; i &lt; dpq.dist.length; i++) &#10;            System.out.println(source + &quot; to &quot; + i + &quot; is &quot;&#10;                               + dpq.dist[i]); &#10;    } &#10;} &#10;  &#10;// Class to represent a node in the graph &#10;class Node implements Comparator&lt;Node&gt; { &#10;    public int node; &#10;    public int cost; // ***** pay attation *****&#10;  &#10;    public Node() &#10;    { &#10;    } &#10;  &#10;    public Node(int node, int cost) &#10;    { &#10;        this.node = node; &#10;        this.cost = cost; &#10;    } &#10;  &#10;    @Override&#10;    public int compare(Node node1, Node node2) &#10;    { &#10;        if (node1.cost &lt; node2.cost) &#10;            return -1; &#10;        if (node1.cost &gt; node2.cost) &#10;            return 1; &#10;        return 0; &#10;    } &#10;} " description="Dijkstra’s shortest path algorithm using PriorityQueue" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bit" value="public class BIT {&#10;    int[] nums;&#10;    int[] BIT;&#10;    int n;&#10;&#10;    public BIT(int[] nums) {&#10;        this.nums = nums;&#10;&#10;        this.n = nums.length;&#10;        this.BIT = new int[this.n + 1];&#10;        for (int i = 0; i &lt; this.n; i++) {&#10;            this.init(i, nums[i]);&#10;        }&#10;    }&#10;&#10;    public void init(int i, int val) {&#10;        i++;&#10;        while (i &lt;= this.n) {&#10;            this.BIT[i] += val;&#10;            i += (i &amp; -i);&#10;        }&#10;    }&#10;&#10;    void update(int i, int val) {&#10;        int diff = val - this.nums[i];&#10;        this.nums[i] = val;&#10;        this.init(i, diff);&#10;    }&#10;&#10;    public int getSum(int i) {&#10;        int sum = 0;&#10;        i++;&#10;        while (i &gt; 0) {&#10;            sum += this.BIT[i];&#10;            i -= (i &amp; -i);&#10;        }&#10;        return sum;&#10;    }&#10;&#10;    public int sumRange(int i, int j) {&#10;        return this.getSum(j) - this.getSum(i - 1);&#10;    }&#10;}" description="Binary Indexed Trees (BIT or Fenwick tree)" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="deltas" value="int[][] deltas = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};" description="deltas" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
</templateSet>