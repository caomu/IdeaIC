<templateSet group="Java">
  <template name="recur" value="private void recursion(int level, int param) {&#10;  // recursion terminator&#10;  if (level &gt; MAX_LEVEL) {&#10;  &#10;    return;&#10;  }&#10;&#10;  // process current layer&#10;  process(level, param);&#10;&#10;  // dig into lower layer&#10;  recursion(level: level + 1, newParam);&#10;&#10;  // clean current layer&#10;&#10;}" description="recursion" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="uf" value="private class UnionFind {&#10;    private int[] roots;&#10;&#10;    protected UnionFind(int n) {&#10;        this.roots = IntStream.range(0, n).toArray();&#10;    }&#10;    &#10;    protected int[] getRoots() {&#10;        return this.roots;&#10;    }&#10;    &#10;    protected void union(int p, int q) {&#10;        roots[this.findRoot(p)] = this.findRoot(q);&#10;    }&#10;&#10;    protected void union(int... p) {&#10;        for (int i = 1; i &lt; p.length; i++) {&#10;            this.union(p[i], p[0]);&#10;        }&#10;    }&#10;&#10;    protected int findRoot(int i) {&#10;        int root = i;&#10;        while (root != roots[root]) {&#10;            root = roots[root];&#10;        }&#10;        int t;&#10;        while (i != roots[root]) {&#10;            t = roots[i];&#10;            roots[i] = root;&#10;            i = t;&#10;        }&#10;        return root;&#10;    }&#10;&#10;    protected boolean isConnected(int p, int q) {&#10;        return this.findRoot(p) == this.findRoot(q);&#10;    }&#10;}" description="union find" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="souta" value="System.out.println(Arrays.toString($ARRAY$));" description="" toReformat="true" toShortenFQNames="true">
    <variable name="ARRAY" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bfs" value="// 计算从起点 start 到终点 target 的最近距离&#10;int BFS(Node start, Node target) {&#10;    Queue&lt;Node&gt; q = new LinkedList&lt;TreeNode&gt;(); // 核心数据结构&#10;    Set&lt;Node&gt; visited = new HashSet&lt;Node&gt;(); // 避免走回头路&#10;    &#10;    q.offer(start); // 将起点加入队列&#10;    visited.add(start);&#10;    int step = 0; // 记录扩散的步数&#10;&#10;    while (!queue.isEmpty()) {&#10;        /* 将当前队列中的所有节点向四周扩散 */&#10;        for (int i = 0; i &lt; q.size(); i++) {&#10;            Node cur = q.poll();&#10;            /* 划重点：这里判断是否到达终点 */&#10;            if (cur is target)&#10;                return step;&#10;            /* 将 cur 的相邻节点加入队列 */&#10;            for (Node x : cur.adj())&#10;                if (x not in visited) {&#10;                    q.offer(x);&#10;                    visited.add(x);&#10;                }&#10;        }&#10;        /* 划重点：更新步数在这里 */&#10;        step++;&#10;    }&#10;}" description="Breadth-first search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="dfs" value="private void dfs(TreeNode node, int level, List&lt;Integer&gt; res, Set&lt;Integer&gt; visited) {&#10;    // check if can end&#10;    if (node == null) {&#10;        return;&#10;    }&#10;    visited.add(node);&#10;    // process current depth level&#10;    if (res.size() == level) {&#10;        res.add(node.val);&#10;    }&#10;    // dig into next depth&#10;    level++;&#10;    if(!visited.contains(node.right)){&#10;        this.dfs(node.right, level, res);&#10;    }&#10;    if(!visited.contains(node.left)) {&#10;        this.dfs(node.left, level, res);&#10;    }&#10;}" description="Depth-First-Search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bs" value="&#10;while(left &lt;= right){&#10;  mid = (left + right) &gt;&gt; 1;&#10;  if(arr[mid] &gt; key) {&#10;    //比关键字大则关键字在左区域&#10;    right = mid - 1;&#10;  } else if(arr[mid] &lt; key) {&#10;    //比关键字小则关键字在右区域&#10;    left = mid + 1;&#10;  } else {&#10;    return mid;&#10;  }" description="Binary Search" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt-iot" value="    /**&#10;     * 递归中序遍历&#10;     * */&#10;    private void inOrderTraversal(TreeNode node, StringBuilder sb){&#10;        if(node==null){ //如果结点为空则返回&#10;            return;&#10;        }&#10;        inOrderTraversal(node.left, sb);//访问左孩子&#10;        sb.append(node.val);//访问根节点&#10;        inOrderTraversal(node.right, sb);//访问右孩子&#10;    }" description="binary tree in-order traversal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt-pot" value="    /**&#10;     * 递归前序遍历&#10;     * */&#10;    private void preOrderTraversal(TreeNode node, StringBuilder sb){&#10;        if(node==null) {//如果结点为空则返回&#10;            return;&#10;        }&#10;        sb.append(node.val);//访问根节点&#10;        preOrderTraversal(node.left, sb);//访问左孩子&#10;        preOrderTraversal(node.right, sb);//访问右孩子&#10;    }" description="binary tree pre-order traversal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="bt-poot" value="    /**&#10;     * 递归后序遍历&#10;     * */&#10;    private void postOrderTraversal(TreeNode node, StringBuilder sb){&#10;        if(node==null) {//如果结点为空则返回&#10;            return;&#10;        }&#10;        postOrderTraversal(node.left, sb);//访问左孩子&#10;        postOrderTraversal(node.right, sb);//访问右孩子&#10;        sb.append(node.val);//访问根节点&#10;    }" description="binary tree post-order traversal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
</templateSet>